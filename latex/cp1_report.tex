\documentclass{article}

\usepackage{packages}
\usepackage{environments}
\usepackage{commands}

% Потребуется для вставки картинки подписи
% \usepackage{graphicx}

\usepackage{titlepage}

% Здесь задаем параметры титульной страницы
% Выбрать одно из двух
%\setToResearch
\setToProgram

\setTitle{3D рендерер с нуля}

% Выбрать одно из трех:
% КТ1 -- \setStageOne
% КТ2 -- \setStageTwo
% Финальная версия -- \setStageFinal
\setStageOne
%\setStageTwo
%\setStageFinal

\setGroup{213}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setStudentSgn{\includegraphics[scale=0.2, trim=-5cm 3cm 0 0]{signature.png}}
\setStudent{Д.С.Бонич}
\setStudentDate{04.02.2023}
\setAdvisor{Дмитрий Витальевич Трушин}
\setAdvisorTitle{доцент, к.ф.-м.н.}
\setAdvisorAffiliation{ФКН НИУ ВШЭ}
\setAdvisorDate{12.06}
\setGrade{11}
% Сюда можно воткнуть картинку подписи с помощью \includegraphics[scale=0.2]{<имя файла>}
% (scale подбирается индивидуально для конкретной картинки)
\setAdvisorSgn{подпись руководителя}
\setYear{2023}


% С этого момента начинается текст документа
\begin{document}

% Эта команда создает титульную страницу
\makeTitlePage

% Здесь будет автоматически генерироваться содержание документа
\tableofcontents

% Данное окружение оформляет аннотацию: краткое описание текста выделенным абзацем после заголовка
\begin{abstract}
    Главной целью данной работы является написание своего 
    собственного 3D-рендерера -- программы для отображения трехмерных объектов на плоский 
    экран компьютера.
\end{abstract}


\section{Введение}

Рендеринг (англ. rendering -- <<визуализация>>) --- это процесс 
получения изображения из модели, его строгого описания. 
Часто под рендерингом подразумевают 3D-рендеринг, где по 
описанию 3-ех мерных объектов строится 2-ух мерное изображение, 
готовое к отображению на плоском экране компьютера. Программа 
осуществляющая ренедеринг называется рендерером, а результат её работы 
рендером. В данной работе мы рассмотрим только 3D-рендеринг и 
3D-рендереры. В настоящее время спектр использования 3D-рендеринга весьма 
широк --- это и программное обеспечение для архитекторов, и 
различные физические симуляции, спецэффекты в фильмах, компьютерные 
игры и много что еще. В рендеринге можно выделить два основных 
типа: real-time и offline рендеринг. Real-time рендеринг подразумевает 
быстрый рендеринг изображения, достаточный для создания эффекта движения на 
экране. Этот тип исползуется в видеоиграх, где важно быстро 
рендерить постоянно меняющуюся модель мира. Offline рендеринг 
может требовать минуты, часы или даже дни для производства рендера, 
но как правило это оправдано высоким качеством финального изображения. 
Такой рендеринг например используется в программах 3D моделлирования
для получения финального рендера и может быть использован для 
создания анимационного фильма. Нас будет интересовать 
real-time рендеринг. При реализации рендеринга на вычислительных 
устройствах существует 2 принципиально разных подхода. Можно 
осуществлять рендеринг с помощью видеокарты, а можно использовать 
только компьютерный процессор. Первый способ является наиболее 
распространенным для real-time рендеринга и часто используется и в offline рендеринге.
Причиной этому служат специфичные потребности алгоритмов осуществляющих рендеринг.
Как правило требуется запускать небольшие программы для каждого 
пикселя. В компьютерной графике такие небольшие программы, которые 
можно выполнять параллельно, называют шейдерами. Так как 
видеокарта имеет большое количество слабых ядер, она является 
идеальным кандидатом для выполнения шейдеров и сильно выигрывает 
в производительности у процессора. Не смотря на это у второго 
подхода есть свои преимущества. Такой способ рендеринга называется
программным рендерингом (software rendering) и может быть 
использован для применения специфичных алгоритмов визуализации, которые 
по каким-то причинам сложно или невозможно реализовать на существующих видеокартах.
Это обусловлено тем, что многие видеокарты фиксируют некоторую 
часть алгоритмов входящих в рендеринг, не позволяя их поменять.
Более того разные видеокарты могут реализовывать одни и те же 
алгоритмы по разному, из-за чего на устройствах с разными видеокартами 
при прочих равных итоговые рендеры могут отличаться. Мы 
будем использовать программный рендеринг, но по другой причине.
Писать код для процессора проще чем для видеокарты и само по себе 
не требует использования дополнительных библиотек. Также это 
позволит нам реализовать весь процесс рендеринга с нуля, не опираясь 
на уже существующие решения внутри видеокарты. Прежде чем начать 
описывать планы на наш рендерер, стоит еще раз уточнить категорию к 
к которой он относится. По применяемым алгоритмам в рендеринге можно 
выделить две наиболее распространенные категории: методы рассматривающие 
лучи света и растеризация. Наш рендерер будет использовать растеризацию. 
Это значит что изначально мы не будем опиратся на свет и будем 
строить все сложные объекты сцены из кирпичиков --- примитивов. 
Основным примитивом для нас будет являтся треугольник, т. к. это выпуклый 
n-угольник с наименьшим количеством вершин позволяющий построить любой 
3-ех мерный многогранник и хорошо аппроксимировать любой 3-ех мерный объект.

Главной целью проекта является реализация собственного 3D программного real-time 
рендерера, использующего поход растеризации в качестве основы.

В планах реализовать следующие фичи:
\begin{itemize}
    \item Растеризация треугольников с соблюдением top-left rule 
    \item Screen-space clipping
    \item Frustrum clipping
    \item Z-buffering
    \item Face culling
    \item Линейная интерполяция значений внутри треугольника с учетом перспективы
    \item Мэппинг текстур на треугольники с учетом перспективы
    \item Набор функций для осуществления линейных преобразований, сдвигов, а также 
    переходов между различными системами координат 
    \item Загрузка и рендеринг моделей, сцен созданных в программах 3D моделлирования 
    \item Источники света: point light, directional light, spotlight 
    \item Gouraud shading, возможно также phong shading
    \item Рендеринг текста с помощью TrueType шрифтов
    \item Реализация программы с использованием MVC паттерна в качестве основы
\end{itemize}

\section{Требования к программе}
\subsection*{Функциональные}
    Программа должна быть способна рендерить \href{https://en.wikipedia.org/wiki/Utah_teapot}{utah teapot} в 30 fps с 
    базовым освещением и разрешением 1920x1080.

\subsection*{Нефункциональные}
Вся программа целиком должна быть написана на C++. Возможно 
использование графических библиотек для вывода отрендереного изображения на экран.
Также могут быть использованы библиотеки с готовыми математическими классами, например с матрицами 
и векторами. Все нетривиальные математические операции должны быть реализованы самостоятельно. 
На настоящий момент используются следующие библиотеки:
\begin{itemize}
    \item \href{https://www.sfml-dev.org/index.php}{SFML} --- для создания окна и вывода изображения на экран 
    \item \href{https://github.com/g-truc/glm}{glm} --- для классов матрицы и вектора, а также базовых 
    операций с ними
\end{itemize}
Сборка проекта осуществляется с помощью \href{https://cmake.org/}{CMake}.


\section{Структура программы}

Рендерер будет включать себя две основные части: графический пайплайн 
и MVC часть позволяющую взаимодействовать с пайплайном. 

\subsection{Обзор графического пайплайна}

Базовая часть пайплайна принимает множество треугольников в 
виде троек вершин. Позиции ожидаются в NDC координатах. Все вершины и
части треугольников выходящие за пределы куба $-1\leq x, y, z\leq 1$ 
будут отсечены. Помимо позиции вершины могут содержать информацию о цвете, 
текстурных координатах, нормалях. 
После обрезки $x$ и $y$ координаты 
переводятся в screen space. $z$ координата используется 
в $z$-буфере для определения какой из пикселей ближе всего 
к зрителю и его стоит отображать. Затем происходит растеризация, 
где каждому пикселю треугольника присваивается какой-то цвет. 
Для определения цвета пикселю нужна информация о цвете, нормали, 
текстурных координатах. Эти значения получаются линейной интерполяцией 
значений из вершин треугольника с поправкой на перспективу. 

Перед передачей примитивов базовому пайплайну рендерер 
преобразует координаты с учетом всех вращений, смещений, растягиваний, 
а также приводит их сначала к camera space, а затем делает 
проекцию перспективы и нормализует координаты внутри view frustrum 
к NDC. 

\subsection{Устройство MVC в программе}
Работа над этой частью рендерера еще не начата. 
План появится после изучения литературы по MVC.


\nocite{OpenGLMath}
\nocite{GameMath}
\nocite{CompGraphicsDynamic}
\nocite{CompGraphicsPolyg}
% Здесь автоматически генерируется библиография. Первая команда задает стиль оформления библиографии, а вторая указывает на имя файла с расширением bib, в котором находится информация об источниках.
\bibliographystyle{plainurl}
\bibliography{bibl}

% Здесь текст документа заканчивается
\end{document}
% Начиная с этого момента весь текст LaTeX игнорирует, можете вставлять любую абракадабру.